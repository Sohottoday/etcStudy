# 자료구조



## 자료구조와 알고리즘

### 자료구조란?

- 용어 : 자료구조, 데이터 구조, data structure
- 대량의 데이터를 효율적으로 관리할 수 있는 데이터의 구조를 의미
- 코드상에서 효율적으로 데이터를 처리하기 위해, 데이터 특성에 따라 체계적으로 데이터를 구조화해야 함
  - 어떤 데이터 구조를 사용하느냐에 따라, 코드 효율이 달라짐



- 효율적으로 데이터를 관리하는 예
  - 우편번호 : 5자리 우편번호로 국가의 기초구역을 제공
    - 5자리 우편번호 앞 3자리는 시, 군, 자칙구를 표기, 뒤 2자리는 일련번호로 구성
  - 학생 관리 : 학년, 반, 번호를 학생에게 부여해서, 학생부를 관리
    - XX학년, X반, X번 학생
    - 만약 위 관리 기법이 없다면 몇천명 몇백명 학생 중 특정 학생을 찾기 위해, 전체 학생부를 모두 훑어야 함
- 대표적인 자료구조
  - 배열, 스택, 큐, 링크드 리스트, 해쉬 테이블, 힙 등
  - 현실 세계의 가장 대표적인 데이터 구조? - 사전



### 알고리즘이란?

- 용어 : 알고리즘, ALGORITHM
- 어떤 문제를 풀기 위한 절차/ 방법
- 어떤 문제에 대해, 특정한 '입력'을 넣으면, 원하는 '출력'을 얻을 수 있도록 만드는 프로그래밍



### 자료구조와 알고리즘이 중요한 이유

- 어떤 자료구조와 알고리즘을 쓰느냐에 따라, 성능이 천지차!



### 자료구조/알고리즘, 그리고 파이썬

- 어떤 언어로든 자료구조/알고리즘 익힐 수 있음
  - 이전에는 무조건 C 또는 C++로만 작성하도록 하는 경우가 많았음
  - 최근에는 언어로 인한 제약/평가는 없어짐



### 데이터 구조

#### 배열(Array)

- 데이터를 나열하고 각 데이터를 인덱스에 대응하도록 구성한 데이터 구조
- 파이썬에서는 리스트 타입이 배열 기능을 제공하고 있음



##### 배열이 필요한 이유

- 같은 종류의 데이터를 효율적으로 관리하기 위해 사용
- 같은 종류의 데이터를 순차적으로 저장



- 배열의 장점
  - 빠른 접근 가능
- 배열의 단점
  - 추가/삭제가 쉽지 않음(지정된 공간만 사용 가능하므로 추가가 어렵고 중간 내용을 삭제한다면 뒤의 내용이 앞으로 붙게 됨)



##### 파이썬과 C언어의 배열 예제

- C

``` c
#include <stdio.h>

int main(int argc, char * argv[])
{
    char country[3] = "US";              # 미리 사이즈를 정하고 배열을 선언해야 함.
    printf("%c%c\n", country[0], country[1]);
    printf("%s\n", country);
    return 0;
}
```

- python

``` python
country = 'US'
print(country)
# US

country = country + 'A'
print(country)           # 파이썬은 이러한 방식으로 배열의 단점이 덜하고 간편하다.
# USA
```



##### 파이썬과 배열

- 파이썬 리스트 활용

``` python
# 1차원 배열 : 리스트로 구현
data = [1, 2, 3, 4, 5]
print(data)
# [1, 2, 3, 4, 5]

# 2차원 배열 : 리스트로 구현시
data = [[1, 2, 3,], [4, 5, 6], [7, 8, 9]]
print(data)
# [[1, 2, 3], [4, 5, 6], [7, 8, 9]]

print(data[0])
# [1, 2, 3]

print(data[1][0])
# 4
print(data[1][1])
# 5
print(data[1][2])
# 6
```





#### 큐(Queue)

- 가장 먼저 넣은 데이터를 가장 먼저 꺼낼 수 있는 구조
  - 음식점에서 가장 먼저 줄을 선 사람이 제일 먼저 음식점에 입장하는 것과 동일
  - FIFO(First-In, First-Out) 또는 LIFO(Last-In, First-Out) 방식으로 스택과 꺼내는 순서가 반대
- 알아둘 용어
  - Enqueue : 큐에 데이터를 넣는 기능
  - Dequeue: 큐에서 데이터를 꺼내는 기능
- 파이썬 queue 라이브러리
  - queue 라이브러리에는 다양한 큐 구조로 Queue(), LifoQueue(), PriorityQueue() 제공
  - 프로그램에 따라 적합한 자료 구조 사용
    - Queue() : 가장 일반적인 큐 자료 구조
    - LifoQueue() : 나중에 입력된 데이터가 먼저 출력되는 구조(스택 구조라고 보면 됨)
    - PriorityQueue(): 데이터마다 우선순위를 넣어서, 우선순위가 높은 순으로 데이터 출력
- 큐가 많이 쓰이는 곳
  - 멀티 태스킹을 위한 프로세스 스케쥴링 방식을 구현하기 위해 많이 사용됨(운영체제 참조)

- ex) 리스트를 변수로 큐를 다루는 enqueue, dequeue 기능 파이썬으로 구현해보기

```  python
queue_list = list()

def enqueue(data):
    queue_list.append(data)
    
def dequeue():
    data = queue_list[0]
    del queue_list[0]
    return data

for index in range(10):
    enqueue(index)
    
len(queue_list)
# 10

dequeue()
# 0

dequeue()
# 1

dequeue()
# 2
```



#### 스택(Stack)

- 데이터를 제한적으로  접근할 수 있는 구조
  - 한쪽 끝에서만 자료를 넣거나 뺄 수 있는 구조
- 가장 나중에 쌓은 데이터를 가장 먼저 빼낼 수 있는 데이터 구조



##### 스택 구조

- 스택은 LIFO(Last In, First Out) 또는 FILO(First In, Last Out) 데이터 관리 방식을 따름
  - LIFO : 마지막에 넣은 데이터를 가장 먼저 추출하는 데이터 관리 정책
  - FILO : 처음에 넣은 데이터를 가장 마지막에 추출하는 데이터 관리 정책
- 대표적인 스택의 활용
  - 컴퓨터 내부의 프로세스 구조의 함수 동작 방식
- 주요 기능
  - push() : 데이터를 스택에 넣기
  - pop() : 데이터를 스택에서 꺼내기



##### 스택 구조와 프로세스 스택

- 스택 구조는 프로세스 실행 구조의 가장 기본
  - 함수 호출시 프로세스 실행 구조를 스택과 비교해서 이해 필요

``` python
# 재귀 함수
def recursive(data):
    if data < 0:
        print("ended")
    else:
        print(data)
        recursive(data - 1)
        print("returned", data)

recursive(4)
# 4
# 3
# 2
# 1
# 0
# ended
# returned 0
# returned 1
# returned 2
# returned 3
# returned 4
```





##### 자료구조 스택의 장단점

- 장점
  - 구조가 단순해서, 구현이 쉽다.
  - 데이터 저장/읽기 속도가 빠르다.
- 단점(일반적인 스택 구현시)
  - 데이터 최대 갯수를 미리 정해야 한다.
    - 파이썬의 경우 재귀 함수는 1000번까지만 호출 가능
  - 저장 공간의 낭비가 발생할 수 있음
    - 미리 최대 갯수만큼 저장 공간을 확보해야 함
  - 스택은 단순하고 빠른 성능을 위해 사용되므로, 보통 배열 구조를 활용해서 구현하는 것이 일반적임. 이 경우, 위에서 열거한 단점이 있을 수 있다.

``` python
data_stack = list()

data_stack.append(1)
data_stack.append(2)

data_stack
# [1, 2]

data_stack.pop()
# 2
data_stack.pop()
# 1
```



##### 리스트 변수로 스택을 다루는 pop, push 기능 구현해보기(pop, push 함수 사용하지 않고)

``` python
stack_list = list()

def push(data):
    stack_list.append(data)
    
def pop():
    data = stack_list[-1]		# 파이썬 index 활용, -1은 맨 뒤를 의미
    del stack_list[-1]
    return data

for index in range(10):
    push(index)
    
pop()
# 9
pop()
# 8
pop()
# 7
```



#### 링크드 리스트(Linked List)

##### 링크드 리스트 구조

- 연결 리스트라고도 함
- 배열은 순차적으로 연결된 공간에 데이터를 나열하는 데이터 구조
- 링크드 리스트는 떨어지 ㄴ곳에 존재하는 데이터를 화살표로 연결해서 관리하는 데이터 구조
- 본래 C언어에서는 주요한 데이터 구조지만, 파이썬은 리스트 타입이 링크드 리스트의 기능을 모두 지원



- 링크드 리스트의 기본 구조와 용어
  - 노드(Node) : 데이터 저장 단위(데이터값, 포인터) 로 구성
  - 포인터(pointer) : 각 노드 안에서, 다음이나 이전의 노드와의 연결 정보를 가지고 있는 공간



##### 간단한 링크드 리스트 예

- Node 구현
  - 보통 파이썬에서 링크드 리스트 구현시, 파이썬 클래스를 활용

``` python
class Node:
    def __init__(self, data, next=None):
        self.data = data
        self.next = next
```



- Node와 Node 연결하기(포인터 활용)

``` python
node1 = Node(1)
node2 = Node(2)         # next 값이 없으므로 주소가 정해지지는 않았다.
node1.next = node2      # 이와 같은 방식으로 연결시킨다.
head = node1         # node1이 맨 앞 값이므로 변수 하나에 담아 처음 주소를 설정해준다.
```



- 링크드 리스트로 데이터 추가하기

``` python
class Node:
    def __init__(self, data, next=None):
        self.data = data
        self.next = next
        
def add(data):
    node = head
    while node.next:
        node = node.next    # while문을 통해 next값이 없을때까지 계속 돈다. 즉, 마지막 노드까지 연결시킨다.
    node.next = Node(data)
    
node1 = Node(1)
head = node1
for index in range(2, 10):
    add(index)
```



- 링크드 리스트 데이터 출력하기(검색하기)

``` python
node = head
while node.next:
    print(node.data)
    node = node.next
print(node.data)
# 1
# 2
# 3
# 4
# 5
# 6
# 7
# 8
# 9
```



##### 링크드 리스트의 장단점(전통적인 C언어에서의 배열과 링크드 리스트)

- 장점
  - 데이터 공간을 미리 할당하지 않아도 됨
  - 배열은 미리 데이터 공간을 할당해야 함
- 단점
  - 연결을 위한 별도 데이터 공간이 필요하므로, 저장공간 효율이 높지 않음
  - 연결 정보를 찾는 시간이 필요하므로 접근 속도가 느림
  - 중간 데이터 삭제시, 앞뒤 데이터 연결을 재구성해야 하는 부가적인 작업 필요



##### 링크드 리스트의 복잡한 기능

- 링크드 리스트 데이터 사이에 데이터를 추가
  - 링크드 리스트는 유지 관리에 부가적인 구현이 필요

``` python
node3 = Node(1.5)

node = head
search = True
while search:
    if node.data ==1:
        search = False
    else:
        node = node.next

node_next = node.next
node.next = node3
node3.next = node_next

node = head
while node.next:
    print(node.data)
    node = node.next
print(node.data)
# 1
# 1.5
# 2
# 3
# 4
# 5
# 6
# 7
# 8
# 9
```



##### 파이썬 객체지향 프로그래밍으로 링크드 리스트 구현

``` python
class Node:
    def __init__(self, data, next = None):
        self.data = data
        self.next = next
    
class NodeMgmt:
    def __init__(self, data):
        self.head = Node(data)
    
    def add(self, data):
        if self.head == '':
            self.head = Node(data)
        else :
            node = self.head
            while node.next:
                node = node.next
            node.next = Node(data)
        
    def desc(self):    # 링크드 리스트 데이터를 순회하는 코드
        node = self.head
        while node:
            print(node.data)
            node = node.next
            
linkedlist1 = NodeMgmt(0)
linkedlist1.desc()
# 0

for data in range(1, 10):
    linkedlist1.add(data)

linkedlist1.desc()
# 0
# 1
# 2
# 3
# 4
# 5
# 6
# 7
# 8
# 9
```



##### 링크드 리스트의 복잡한 기능2

- 특정 노드를 삭제

``` python
class Node:
    def __init__(self, data, next = None):
        self.data = data
        self.next = next
    
class NodeMgmt:
    def __init__(self, data):
        self.head = Node(data)
    
    def add(self, data):
        if self.head == '':
            self.head = Node(data)
        else :
            node = self.head
            while node.next:
                node = node.next
            node.next = Node(data)
        
    def desc(self):    # 링크드 리스트 데이터를 순회하는 코드
        node = self.head
        while node:
            print(node.data)
            node = node.next
            
    def delete(self, data):
        if self.head == '':
            print("해당 값을 가진 노드가 없습니다.")
            return
        
        if self.head.data == data:
            temp = self.head
            self.head = self.head.next    # 헤드를 지우는 경우 : 헤드의 주소와 내용이 삭제되고 그 다음 노드의 주소가 헤드주소로 바뀐다.
            del temp
        else :
            node = self.head
            while node.next :
                if node.next.data == data:
                    temp = node.next
                    node.next = node.next.next    # 중간 노드를 지우는 경우 : 지우는 노드의 뒷 노드를 앞 노드와 연결시킨다.
                    del temp
                    return
                else :
                    node = node.next     # 마지막 노드를 지우는 경우
```

``` python
linkedlist1 = NodeMgmt(0)
linkedlist1.desc()
# 0

# head가 살아있음을 확인
linkedlist1.head
# <__main__.Node at 0x2a2feafb6c8>

# head를 지워봄
linkedlist1.delete(0)

# 아무것도 나오지 않으면 정삭적으로 삭제되었음을 의미
linkedlist1.head

linkedlist1 = NodeMgmt(0)

for data in range(1, 10):
    linkedlist1.add(data)

linkedlist1.desc()
# 0
# 1
# 2
# 3
# 4
# 5
# 6
# 7
# 8
# 9

# 노드 중 한개를 삭제
linkedlist1.delete(4)

linkedlist1.desc()
# 0
# 1
# 2
# 3
# 5
# 6
# 7
# 8
# 9

# 마지막 노드 삭제
linkedlist1.delete(9)

linkedlist1.desc()
# 0
# 1
# 2
# 3
# 5
# 6 
# 7
# 8
```



- 특정 노드를 찾는 코드 추가

``` python
    def search(self, data):
        node = self.head
        while node:
            if node.data == data:
                return node
            else:
                node = node.next
                
  # 테스트
node_mgmt = NodeMgmt(0)
for data in range(1, 10):
    node_mgmt.add(data)

node = node_mgmt.search(4)
print(node.data)  
# 4
```



##### 다양한 링크드 리스트 구조

- 더블 링크드 리스트(Doubly linked list) 기본 구조

  - 이중 연결 리스트라고도 함

  - 장점 : 양방향으로 연결되어 있어서 노트 탐색이 양쪽으로 모두 가능

    자료가 많을 경우 기존 링크드 리스트는 탐색 시간이 오래 걸림

![linkedlist double](https://user-images.githubusercontent.com/58559786/90969280-b02b3000-e531-11ea-954e-1460deaadac5.PNG)

``` python
class Node:
    def __init__(self, data, prev=None, next=None):    # 앞 주소와 뒷 주소 둘 다 필요
        self.prev = prev
        self.data = data
        self.next = next
        
class NodeMgmt:
    def __init__(self, data):
        self.head = Node(data)
        self.tail = self.head      # 일반적인 링크드리스토와 다르게 뒤에서부터 검색 할 경우도 생각한다.
        
    def insert(self, data):
        if self.head == None:
            self.head = Node(data)
            self.tail = self.head
        else:
            node = self.head
            while node.next:
                node = node.next    # 노드의 끝을 찾아가는 코드. 즉, 반복문이 끝나면 next가 None인 노드를 갖고있을 것이다.
            new = Node(data)
            node.next = new
            new.prev = node
            self.tail = new
            
    def desc(self):
        node = self.head
        while node:
            print(node.data)
            node = node.next    # next가 None이 될 때 까지 출력하는 코드
     
double_linkedlist = NodeMgmt(0)
for data in range(1, 10):
    double_linkedlist.insert(data)
    
double_linkedlist.desc()
# 0
# 1
# 2
# 3
# 4
# 5
# 6
# 7
# 8
# 9
```

- 노드 데이터가 특정 숫자인 노드 앞에 데이터를 추가하는 함수

``` python
class Node:
    def __init__(self, data, prev=None, next=None):    # 앞 주소와 뒷 주소 둘 다 필요
        self.prev = prev
        self.data = data
        self.next = next
        
class NodeMgmt:
    def __init__(self, data):
        self.head = Node(data)
        self.tail = self.head      # 일반적인 링크드리스토와 다르게 뒤에서부터 검색 할 경우도 생각한다.
        
    def insert(self, data):
        if self.head == None:
            self.head = Node(data)
            self.tail = self.head
        else:
            node = self.head
            while node.next:
                node = node.next    # 노드의 끝을 찾아가는 코드. 즉, 반복문이 끝나면 next가 None인 노드를 갖고있을 것이다.
            new = Node(data)
            node.next = new
            new.prev = node
            self.tail = new
            
    def desc(self):
        node = self.head
        while node:
            print(node.data)
            node = node.next    # next가 None이 될 때 까지 출력하는 코드
        
    def search_from_head(self, data):    # head 부터 찾을 경우
        if self.head == None:
            return False
            
        node = self.head
        while node:
            if node.data == data:
                return node
            else:
                node = node.next
        return False
    
    def search_from_tail(self, data):    # tail 부터 찾을 경우
        if self.head == None:
            return False
            
        node = self.tail
        while node:
            if node.data == data:
                return node
            else:
                node = node.prev
        return False
    
    def insert_before(self, data, before_data):
        if self.head == None:
            self.head = Node(data)
            return True
        else:
            node = self.tail
            while node.data != before_data:    # 넣으려고 정해준 값과 반복문을 통해 찾는 데이터의 값이 같지 않음을 통해 찾는다.
                node = node.prev
                if node == None:
                    return False
            new = Node(data)    # 반복문을 넘어왔다는 것은 데이터를 넣으려는 위치를 찾았따는 의미
            before_new = node.prev
            before_new.next = new
            new.prev = before_new
            new.next = node
            node.prev = new      # 노드끼리 연결시키는 코드
            return True
        
```

``` python
double_linkedlist = NodeMgmt(0)
for data in range(1, 10):
    double_linkedlist.insert(data)
    
node_s = double_linkedlist.search_from_head(3)
node_s.data
# 3

node_s = double_linkedlist.search_from_tail(4)
node_s.data
# 4

double_linkedlist.insert_before(1.5, 2)
double_linkedlist.desc()
# 0
# 1
# 1.5
# 2
# 3
# 4
# 5
# 6
# 7
# 8
# 9
```



#### 해쉬 테이블(Hash Table)

##### 해쉬 구조

- Hash Table : 키(key)에 데이터(Value)를 저장하는 데이터 구조
  - key를 통해 바로 데이터를 받아올 수 있으므로, 속도가 획기적으로 빨라짐
  - 파이썬 딕셔너리(Dictonary) 타입이 해쉬 테이블의 예 : key를 가지고 바로 데이터를 꺼냄
  - 보통 배열로 미리 Hash Table 사이즈만큼 생성 후에 사용(공간과 탐색 시간을 맞바꾸는 기법)
  - 단, 파이썬에서는 해쉬를 별도 구현할 이유가 없음 - 딕셔너리 타입을 사용



##### 알아둘 용어

- 해쉬(Hash) : 임의 값을 고정 길이로 변환하는 것
- 해쉬 테이블(Hash Table) : 키 값의 연산에 의해 직접 접근이 가능한 데이터 구조
- 해싱 함수(Hashing Function) : key에 대해 산술 연산을 이용해 데이터 위치를 찾을 수 있는 함수
- 해쉬 값(Hash Value) 또는 해쉬 주소(Hash Address) : key를 해싱 함수로 연산해서, 해쉬 값을 알아내고, 이를 기반으로 해쉬 테이블에서 해당 key에 대한 데이터 위치를 일관성있게 찾을 수 있음
- 슬롯(Slot) : 한 개의 데이터를 저장할 수 있는 공간
- 저장할 데이터에 대해 key를 추천할 수 있는 별도 함수도 존재할 수 있음



##### 자료 구조 해쉬 테이블의 장단점과 주요 용도

- 장점
  - 데이터 저장/읽기 속도가 빠르다.(검색 속도가 빠르다)
  - 해쉬는 키에 대한 데이터가 있는지(중복) 확인이 쉽다.
- 단점
  - 일반적으로 저장공간이 좀 더 많이 필요하다.
  - 여러 키에 해당하는 주소가 동일할 경우 충돌을 해결하기 위한 별도 자료구조가 필요하다.
- 주요 용도
  - 검색이 많이 필요한 경우
  - 저장, 삭제, 읽기가 빈번한 경우
  - 캐쉬 구현시(중복 확인이 쉽기 때문)



##### 프로그래밍 연습

- hash table 만들기

``` python
hash_table = list([0 for i in range(10)])        # list comprehension
hash_table
# [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]

# 초간단 해쉬함수 만들어보기
## 다양한 해쉬 함수 고안 기법이 있으며, 가장 간단한 방식이 Division 법(나누기를 통한 나머지 값을 사용하는 기법)
def hash_func(key):
    return key % 5

# 해쉬 테이블에 저장
## 데이터에 따라 필요시 key 생성 방법 정의가 필요
data1 = 'andy'
data2 = 'dave'
data3 = 'trump'

## ord() : 문자의 ASCII(아스키) 코드 리턴

print(ord(data1[0]), ord(data2[0]), ord(data3[0]))
# 97 100 116
print(ord(data1[0]), hash_func(ord(data1[0])))
# 97 2

# 해쉬 테이블에 값 저장 예
## data:value 와 같이 data와 value를 넣으면, 해당 data에 대한 key를 찾아서, 해당 key에 대응하는 해쉬주소에 value를 저장하는 예
def storage_data(data, value):
    key = ord(data[0])
    hash_address = hash_func(key)
    hash_table[hash_address] = value
    
# 해쉬 테이블에서 특정 주소의 데이터를 가져오는 함수 생성
storage_data('andy', '01055554444')
storage_data('dave', '01044443333')
storage_data('trump', '01011112222')

# 실제 데이터를 저장하고 읽어보기
def get_data(data):
    key = ord(data[0])
    hash_address = hash_func(key)
    return hash_table[hash_address]

get_data('andy')
# '01055554444'
```



- 리스트 변수를 활용해서 해쉬 테이블 구현해보기

  - 해쉬 함수 : key % 8
  - 해쉬 키 생성 : hash(data)

  ``` python
  hash("Dave")        # 랜덤으로 해쉬값을 지정해주는 함수 hash()
  # 5484401433555540922
  ```

``` python
hash_table = list([0 for i in range(8)])

def get_key(data):
    return hash(data)

def hash_function(key):
    return key % 8

def save_data(data, value):
    hash_address = hash_function(get_key(data))
    hash_table[hash_address] = value

def read_data(data):
    hash_address = hash_function(get_key(data))
    return hash_table[hash_address]

save_data('David', '01011112222')
save_data('Andy', '01033334444')
read_data('David')
# '01011112222'

hash_table
# [0, 0, '01011112222', 0, 0, 0, '01033334444', 0]
```





### 알고리즘

#### 알고리즘 복잡도 표현 방법 : 시간 복잡도

1. **알고리즘 복잡도 계산이 필요한 이유**

- 하나의 문제를 푸는 알고리즘은 다양할 수 있음
  - 정수의 절대값 구하기
    - 방법 1 : 정수값을 제곱한 값에 다시 루트를 씌우기
    - 방법 2 : 정수가 음수인지 확인해서, 음수일 때만, -1을 곱하기
  - 다양한 알고리즘 중 어느 알고리즘이 더 좋은지를 분석하기 위해, 복잡도를 정의하고 계산함



2. **알고리즘 복잡도 계산 항목**

- 시간 복잡도 : 알고리즘 실행 속도
- 공간 복잡도 : 알고리즘이 사용하는 메모리 사이즈

(가장 중요한 시간 복잡도를 꼭 이해하고 계산할 수 있어야 함)

- 알고리즘 시간 복잡도의 주요 요소
  
- 반복문이 지배(반복문으로 시간 복잡도를 계산)
  
- ex)  자동차로 서울에서 부산을 가기 위해, 다음과 같이 항목을 나누었을 때, 가장 총 시간에 영향을 많이 미칠 것 같은 요소는?

  - 자동차로 서울에서 부산 가기
    1. 자동차 문열기
    2. 자동차 문닫기
    3. 자동차 운전석 등받이 조정하기
    4. 자동차 시동걸기
    5. 자동차로 서울에서 부산가기
    6. 자동차 시동 끄기
    7. 자동차 문열기
    8. 자동차 문닫기

- 반복문을 어떻게 구성하느냐에 따라 알고리즘의 시간복잡도가 계산된다

  프로그래밍에서 시간 복잡도에 가장 영향을 많이 미치는 요소는 반복문

  ​	입력의 크기가 커지면 커질수록 반복문이 알고리즘 수행 시간을 지배함

3. **알고리즘 성능 표기법**

- Big O (빅-오) 표기법 : O(N)
  - 알고리즘 최악의 실행 시간을 표기
  - 가장 많이/일반적으로 사용함
  - 아무리 최악의 상황이라도, 이정도의 성능은 보장한다는 의미이기 때문
- Ω (오메가) 표기법 : Ω(N)
  - 오메가 표기법은 알고리즘 최상의 실행 시간을 표기
- Θ (세타) 표기법 : Θ(N)
  - 오메가 표기법은 알고리즘 평균 실행 시간을 표기

(시간 복잡도 계산은 반복문이 핵심 요소임을 인지하고, 계산 표기는 최상, 평균, 최악 중 최악의 시간인 Big-O 표기법을 중심으로 익히면 됨)

4. **대문자 O 표기법**

- 빅 오 표기법, Big-O 표기법 이라고도 부름

- O(입력)

  - 입력 n에 따라 결정되는 시간 복잡도 함수
  - O(1), O($$ log n $$), O(n), O($$ n log n $$), O($$ n^2 $$), O($$ 2^n $$), O(n!) 등으로 표기함
  - 입력 n의 크기에 따라 기하급수적으로 시간 복잡도가 늘어날 수 있음
    - O(1) < O($$ log n $$) < O(n) < O($$ n log n $$) < O($$ n^2 $$) < O($$ 2^n $$) < O(n!)
    - 참고 : log n 의 베이스는 $$ 2 - log_{2}n $$

- 단순하게 입력 n에 따라, 몇번 실행이 되는지를 계산하면 된다.

  - 표현식에 가장 큰 영향을 미치는 n의 단위로 표기

  - n이 1이든 100이든, 1000이든, 10000이든 실행을

    - 무조건 2회(상수회) 실행한다 : O(1)

    ``` python
    if n > 10:
        print(n)		# n이 어떠한 값이든 1회 수행
    ```

    - n에 따라 n번, n + 10번, 또는 3n + 10번 등 실행한다 : O(n)

    ``` python
    for index in range(n):
        print(index)		# n의 수 만큼 실행
        
    variable = 1
    for num in range(3):
        for index in range(n):
            print(index)
    ```

    - n에 따라 $$ n^2 $$번, $$ n^2 + 1000 $$번, 또는 $$ 100n^2 - 1000$$번 등 실행한다. : O($$n^2$$)

  - 빅 오 입력값 표기 방법
    - 만약 시간 복잡도 함수가 $ 2n^2 + 3n $ 이라면
      - 가장 높은 차수는 $2n^2$
      - 상수는 실제 큰 영향이 없음
      - 결국 빅 오 표기법으로는 O($ n^2 $)(서울부터 부산까지 가는 자동차의 예를 상기)

  - 1부터 n까지의 합을 구하는 알고리즘1
    - 합을 기록할 변수를 만들고 0을 저장
    - n을 1부터 1씩 증가시키면서 반복
    - 반복문 안에서 합을 기록할 변수에 1씩 증가된 값을 더함
    - 반복이 끝나면 합을 출력

  ``` python
  def sum_all(n):
      total = 0
      for num in range(1, n+1):
          total += num
      return total
  
  sum_all(100)
  # 5050
  ```

  - 시간 복잡도 구하기
    - 1부터 n까지의 합을 구하는 알고리즘1
      - 입력 n에 따라 덧셈을 n번 해야 함(반복문)
      - 시간 복잡도 : n, 빅 오 표기법으로는 O(n)

  

  - 알고리즘 2 : 1부터 n까지의 합을 구하는 알고리즘 2
    - $$ n(n+1) \above 1pt 2 $$

  ``` python
  def sum_all(n):
      return int(n * (n + 1) / 2)
  
  sum_all(100)
  # 5050
  ```

  - 시간 복잡도 구하기
    - 1부터 n까지의 합을 구하는 알고리즘2
      - 입력 n이 어떻든 간에, 곱셈/ 덧셈/ 나눗셈 하면 됨(반복문이 없음)
      - 시간 복잡도 : 1, 빅 오 표기법으로는 O(1)
  - 어느 알고리즘 성능이 더 뛰어난가?
    - 알고리즘 1 vs 알고리즘 2
    - O(n) vs O(1)
    - 이와 같이, 동일한 문제를 푸는 알고리즘은 다양할 수 있음, 어느 알고리즘이 보다 좋은지를 객관적으로 비교하기 위해, 빅 오 표기법 등으로 시간복잡도 계산법을 사용함



#### 충돌(Collision) 해결 알고리즘(좋은 해쉬 함수 사용하기)

- 해쉬 테이블의 가장 큰 문제는 충돌(Collision)의 경우입니다. 이 문제를 충돌(Collision) 또는 해쉬 충돌(Hash Collision)이라고 부릅니다.

##### Chaining 기법

- 개방 해슁 또는 Open Hashing 기법 중 하나 : 해쉬 테이블 저장공간 외의 공간을 활용하는 기법
- 충돌이 일어나면, 링크드 리스트라는 자료 구조를 사용해서, 링크드 리스트로 데이터를 추가로 뒤에 연결시켜 저장하는 기법

``` python
hash_table = list([0 for i in range(8)])

def get_key(data):
    return hash(data)

def hash_function(key):
    return key % 8

def save_data(data, value):
    index_key = get_key(data)
    hash_address = hash_function(index_key)
    if hash_table[hash_address] != 0 :         # 초기에 default 값을 0으로 지정했으므로(1 line)
        for index in range(len(hash_table[hash_address])):
            if hash_table[hash_address][index][0] == index_key:
                hash_table[hash_address][index][1] = value
                return
        hash_table[hash_address].append([index_key, value])
    else:
        hash_table[hash_address] = list([index_key, value])

def read_data(data):
    index_key = get_key(data)
    hash_address = hash_function(index_key)
    if hash_table[hash_address] != 0:
        for index in range(len(hash_table[hasdh_address])):
            if hash_table[hash_address][index][0] == index_key:
                return hash_table[hash_address][index][1]
        return None
    else :
        return None
    
```



##### Linear Probing 기법

- 폐쇄 해슁 또는 Close Hashing 기법 중 하나 : 해쉬 테이블 저장공간 안에서 충돌 문제를 해결하는 기법
- 충돌이 일어나면, 해당 hash address의 다음 address부터 맨 처음 나오는 빈 공간에 저장하는 기법
  - 저장공간 활용도를 높이기 위한 기법

``` python
hash_table = list([0 for i in range(8)])

def get_key(data):
    return hash(data)

def hash_function(key):
    return key % 8

def save_data(data, value):
    index_key = get_key(data)
    hash_address = hash_function(index_key)
    if hash_table[hash_address] != 0 :         # 초기에 default 값을 0으로 지정했으므로(1 line)
        for index in range(hash_address, len(hash_table)):
            if hash_table[index] == 0:
                hash_table[index] = [index_key, value]
                return
            elif hash_table[index][0] == index_key:
                hash_table[index][1] = value
                return
    else :
        hash_table[hash_address] = [index_key, value]
    # chaining 기법과 달리 다음 주소의 빈 공간에 key와 함께 value값 삽입
        
def read_data(data):
    index_key = get_key(data)
    hash_address = hash_function(index_key)
    if hash_table[hash_address] != 0:
        for index in range(hash_address, len(hash_table)):
            if hash_table[index] == 0:
                return None
            elif hash_table[index][0] == index_key:
                return hash_table[index][1]
    else:
        return None
```





## jupyter notebook



- run 했을 때 [ ] 안이 숫자가 아닌 * 가 나올 경우 셀의 수행이 아직 끝나지 않았다는 것을 의미

  이러한 경우 그 다음 셀에 끝낼 수 있는 마무리 작업이 필요하다.

  ex) 반복문 실수 등

- 단축키
  - 셀 선택 후 A : 선택 셀 위에 새로운 셀 삽입
  - 셀 선택 후 B : 선택 셀 아래에 새로운 셀 삽입

